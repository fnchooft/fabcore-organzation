.for schema.entity as current_entity
.  define EntityName = current_entity.name
.  define ENTITY_NAME_UPPER = "$(current_entity.name:upper)"
.  define HeaderFile = "$(EntityName).h"
.  define SourceFile = "$(EntityName).c"
.  output "$(HeaderFile)"
// $(HeaderFile) - Generated by GSL for entity $(EntityName)

#ifndef $(ENTITY_NAME_UPPER)_H
#define $(ENTITY_NAME_UPPER)_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// --- Definition for $(EntityName) struct ---
typedef struct $(EntityName) {
.  for current_entity.field as f
  $(f.type) $(f.name); // $(f.desc:); 
.  endfor
} $(EntityName);

// --- Definition for $(EntityName)Node (Linked List Node) ---
typedef struct $(EntityName)Node {
  $(EntityName) data; // Embeds the actual entity data
  struct $(EntityName)Node *next;
} $(EntityName)Node;

// --- Function Prototypes for $(EntityName) Linked List ---
$(EntityName)Node* create$(EntityName)Node(
.  for current_entity.field as f
.    if f.type = "char*"
  const $(f.type) $(f.name)$(last(f)??''?',')
.    else
  $(f.type) $(f.name)$(last(f)??''?',')
.    endif
.  endfor
);

void add$(EntityName)ToList($(EntityName)Node** head, $(EntityName)Node* newNode);
void print$(EntityName)(const $(EntityName)* entityData);
void print$(EntityName)List(const $(EntityName)Node* head);
void free$(EntityName)List($(EntityName)Node** head);

#endif // $(ENTITY_NAME_UPPER)_H
.  close
.  output "$(SourceFile)"
// $(SourceFile) - Generated by GSL for entity $(EntityName)

#include "$(HeaderFile)"
#include <string.h>
// --- Function to create a new $(EntityName)Node ---
$(EntityName)Node* create$(EntityName)Node(
.  for current_entity.field as f
.    if f.type = "char*"
  const $(f.type) $(f.name)$(last(f)??''?',')
.    else
  $(f.type) $(f.name)$(last(f)??''?',')
.    endif
.  endfor
) {
  $(EntityName)Node* newNode = ($(EntityName)Node*)malloc(sizeof($(EntityName)Node));
  if (newNode == NULL)  goto $(EntityName:c)_cleanup;

  // Initialize data fields
.  for current_entity.field as f
.    if f.type = "char*"
  newNode->data.$(f.name) = strdup($(f.name));
  if (newNode->data.$(f.name) == NULL && $(f.name) != NULL) goto $(EntityName:c)_cleanup;
.  else
  newNode->data.$(f.name) = $(f.name);
.  endif
.  endfor

  newNode->next = NULL;
  return newNode;

$(EntityName:c)_cleanup:
  // Initialize data fields
.  for current_entity.field as f
.    if f.type = "char*"
  free(newNode->data.$(f.name));
.    endif
.  endfor
  free(newNode);
  return NULL;
}

// --- Function to add a $(EntityName)Node to the end of the list ---
void add$(EntityName)ToList($(EntityName)Node** head, $(EntityName)Node* newNode) {
  if (newNode == NULL) return;
  if (*head == NULL) {
    *head = newNode;
  } else {
    $(EntityName)Node* current = *head;
    while (current->next != NULL) {
      current = current->next;
    }
    current->next = newNode;
  }
}

// --- Function to print details of a single $(EntityName) ---
void print$(EntityName)(const $(EntityName)* entityData) {
    if (entityData == NULL) {
      printf("  (null $(EntityName) data)\\n");
      return;
    }
    printf("  $(EntityName) Details:\\n");
.  for current_entity.field as f
.    if f.type = "char*"
    printf("    $(f.name): %s\\n", entityData->$(f.name) ? entityData->$(f.name) : "(null)");
.    elsif f.type = "int"
    printf("    $(f.name): %d\\n", entityData->$(f.name));
.    elsif f.type = "double"
    printf("    $(f.name): %.2f\\n", entityData->$(f.name));
.    else
    printf("    $(f.name): [unsupported type for printing: $(f.type)]\\n");
.    endif
.  endfor
}

// --- Function to print all $(EntityName)s in the list ---
void print$(EntityName)List(const $(EntityName)Node* head) {
  const $(EntityName)Node* current = head;
  if (current == NULL) {
    printf("$(EntityName) list is empty.\\n");
    return;
  }
  printf("\\n--- $(EntityName) List ---\\n");
  int count = 1;
  while (current != NULL) {
    printf("Node %d:\\n", count++);
    print$(EntityName)(&(current->data));
    current = current->next;
  }
  printf("----------------------\\n");
}

// --- Function to free the entire $(EntityName) linked list ---
void free$(EntityName)List($(EntityName)Node** head) {
  $(EntityName)Node* current = *head;
  $(EntityName)Node* nextNode;
  while (current != NULL) {
    nextNode = current->next;
    // Free dynamically allocated strings within the data struct
.    for current_entity.field as f
.      if f.type = "char*"
    free(current->data.$(f.name));
.      endif
.    endfor
    free(current); // Free the node itself
    current = nextNode;
  }
  *head = NULL;
}
.  close
.  echo "Generated $(HeaderFile) and $(SourceFile) for entity $(EntityName)"
.endfor
