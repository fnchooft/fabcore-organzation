
---
description: GSL Templating using Gemini 2.5 Pro
---

# Generator Scripting Language - teaching Gemini

During a recent course AI was explained and someone mentioned that
Gemini performs better then DeepSeek and ChatGPT in coding tasks.

So I took that opertunity to:

1. Teach Gemini about GSL ( www.github.com/zeromq/gsl)
2. Provide the README.txt file as context
3. Explain what I wanted.

## The assignment

I want to teach you about GSL, more context is provided here: [README.txt](https://github.com/zeromq/gsl/blob/master/README.txt).

Ask: Write an entities.xml file which contains some entities with typical fields such as name,age etc.

Gemini produced: 

### entities.xml

```xml
<?xml version="1.0"?>

<schema script="entity_generator.gsl">

  <entity name="interface">
    <field name="id" type="int" desc="Unique identifier for the interface"/>
    <field name="name" type="char*" desc="First name of the interface"/>
    <field name="type" type="char*" desc="Last name of the interface"/>
    <field name="enabled" type="int" desc="Age of the interface"/>
  </entity>

  <!-- Add more entities here as needed -->
  <!--
  <entity name="Person">
    <field name="id" type="int" desc="Unique identifier for the person"/>
    <field name="firstName" type="char*" desc="First name of the person"/>
    <field name="lastName" type="char*" desc="Last name of the person"/>
    <field name="age" type="int" desc="Age of the person"/>
  </entity>

  <entity name="Product">
    <field name="sku" type="char*" desc="Stock Keeping Unit"/>
    <field name="name" type="char*" desc="Name of the product"/>
    <field name="price" type="double" desc="Price of the product"/>
    <field name="quantity" type="int" desc="Available quantity in stock"/>
  </entity>

  <entity name="Order">
    <field name="orderId" type="int" desc="Unique order identifier"/>
    <field name="customerId" type="int" desc="ID of the customer placing the order"/>
    <field name="orderDate" type="char*" desc="Date the order was placed (e.g., YYYY-MM-DD)"/>
  </entity>
  -->
</schema>

```

After this I requested it to write the gsl-template to generate, on the basis of the entity-format C-structs.

### entity_generator.gsl
The resulting template after some back and forth looks like this:

```c
.for schema.entity as current_entity
.  define EntityName = current_entity.name
.  define ENTITY_NAME_UPPER = "$(current_entity.name:upper)"
.  define HeaderFile = "$(EntityName).h"
.  define SourceFile = "$(EntityName).c"
.  output "$(HeaderFile)"
// $(HeaderFile) - Generated by GSL for entity $(EntityName)

#ifndef $(ENTITY_NAME_UPPER)_H
#define $(ENTITY_NAME_UPPER)_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// --- Definition for $(EntityName) struct ---
typedef struct $(EntityName) {
.  for current_entity.field as f
  $(f.type) $(f.name); // $(f.desc:); 
.  endfor
} $(EntityName);

// --- Definition for $(EntityName)Node (Linked List Node) ---
typedef struct $(EntityName)Node {
  $(EntityName) data; // Embeds the actual entity data
  struct $(EntityName)Node *next;
} $(EntityName)Node;

// --- Function Prototypes for $(EntityName) Linked List ---
$(EntityName)Node* create$(EntityName)Node(
.  for current_entity.field as f
.    if f.type = "char*"
  const $(f.type) $(f.name)$(last(f)??''?',')
.    else
  $(f.type) $(f.name)$(last(f)??''?',')
.    endif
.  endfor
);

void add$(EntityName)ToList($(EntityName)Node** head, $(EntityName)Node* newNode);
void print$(EntityName)(const $(EntityName)* entityData);
void print$(EntityName)List(const $(EntityName)Node* head);
void free$(EntityName)List($(EntityName)Node** head);

#endif // $(ENTITY_NAME_UPPER)_H
.  close
.  output "$(SourceFile)"
// $(SourceFile) - Generated by GSL for entity $(EntityName)

#include "$(HeaderFile)"
#include <string.h>
// --- Function to create a new $(EntityName)Node ---
$(EntityName)Node* create$(EntityName)Node(
.  for current_entity.field as f
.    if f.type = "char*"
  const $(f.type) $(f.name)$(last(f)??''?',')
.    else
  $(f.type) $(f.name)$(last(f)??''?',')
.    endif
.  endfor
) {
  $(EntityName)Node* newNode = ($(EntityName)Node*)malloc(sizeof($(EntityName)Node));
  if (newNode == NULL)  goto $(EntityName:c)_cleanup;

  // Initialize data fields
.  for current_entity.field as f
.    if f.type = "char*"
  newNode->data.$(f.name) = strdup($(f.name));
  if (newNode->data.$(f.name) == NULL && $(f.name) != NULL) goto $(EntityName:c)_cleanup;
.  else
  newNode->data.$(f.name) = $(f.name);
.  endif
.  endfor

  newNode->next = NULL;
  return newNode;

$(EntityName:c)_cleanup:
  // Initialize data fields
.  for current_entity.field as f
.    if f.type = "char*"
  free(newNode->data.$(f.name));
.    endif
.  endfor
  free(newNode);
  return NULL;
}

// --- Function to add a $(EntityName)Node to the end of the list ---
void add$(EntityName)ToList($(EntityName)Node** head, $(EntityName)Node* newNode) {
  if (newNode == NULL) return;
  if (*head == NULL) {
    *head = newNode;
  } else {
    $(EntityName)Node* current = *head;
    while (current->next != NULL) {
      current = current->next;
    }
    current->next = newNode;
  }
}

// --- Function to print details of a single $(EntityName) ---
void print$(EntityName)(const $(EntityName)* entityData) {
    if (entityData == NULL) {
      printf("  (null $(EntityName) data)\\n");
      return;
    }
    printf("  $(EntityName) Details:\\n");
.  for current_entity.field as f
.    if f.type = "char*"
    printf("    $(f.name): %s\\n", entityData->$(f.name) ? entityData->$(f.name) : "(null)");
.    elsif f.type = "int"
    printf("    $(f.name): %d\\n", entityData->$(f.name));
.    elsif f.type = "double"
    printf("    $(f.name): %.2f\\n", entityData->$(f.name));
.    else
    printf("    $(f.name): [unsupported type for printing: $(f.type)]\\n");
.    endif
.  endfor
}

// --- Function to print all $(EntityName)s in the list ---
void print$(EntityName)List(const $(EntityName)Node* head) {
  const $(EntityName)Node* current = head;
  if (current == NULL) {
    printf("$(EntityName) list is empty.\\n");
    return;
  }
  printf("\\n--- $(EntityName) List ---\\n");
  int count = 1;
  while (current != NULL) {
    printf("Node %d:\\n", count++);
    print$(EntityName)(&(current->data));
    current = current->next;
  }
  printf("----------------------\\n");
}

// --- Function to free the entire $(EntityName) linked list ---
void free$(EntityName)List($(EntityName)Node** head) {
  $(EntityName)Node* current = *head;
  $(EntityName)Node* nextNode;
  while (current != NULL) {
    nextNode = current->next;
    // Free dynamically allocated strings within the data struct
.    for current_entity.field as f
.      if f.type = "char*"
    free(current->data.$(f.name));
.      endif
.    endfor
    free(current); // Free the node itself
    current = nextNode;
  }
  *head = NULL;
}
.  close
.  echo "Generated $(HeaderFile) and $(SourceFile) for entity $(EntityName)"
.endfor

```

I then asked it to generate a main.c file and a Makefile in order to compile the entire example:

### main.c

```c
// main.c
#include <stdio.h>

// Include the generated headers for each entity
#include "Person.h"
#include "Product.h"
// #include "Order.h" // If you add an Order entity

int main() {
    printf("--- Generic Entity Linked List Demo ---\n");

    // --- Person Demo ---
    PersonNode *personList = NULL;
    PersonNode *p1_node = createPersonNode(1, "Alice", "Smith", 30);
    PersonNode *p2_node = createPersonNode(2, "Bob", "Johnson", 25);
    PersonNode *p3_node = createPersonNode(3, "Charlie", "Williams", 42);

    addPersonToList(&personList, p1_node);
    addPersonToList(&personList, p2_node);
    addPersonToList(&personList, p3_node);

    printPersonList(personList);
    freePersonList(&personList);
    printf("Person list after freeing:\n");
    printPersonList(personList); // Should be empty

    // --- Product Demo ---
    ProductNode *productList = NULL;
    ProductNode *prod1_node = createProductNode("SKU001", "Laptop Pro", 1200.50, 10);
    ProductNode *prod2_node = createProductNode("SKU002", "Wireless Mouse", 25.99, 50);

    addProductToList(&productList, prod1_node);
    addProductToList(&productList, prod2_node);

    printProductList(productList);
    freeProductList(&productList);
    printf("Product list after freeing:\n");
    printProductList(productList); // Should be empty

    /*
    // --- Order Demo (if Order entity is defined) ---
    OrderNode *orderList = NULL;
    OrderNode *ord1_node = createOrderNode(1001, 1, "2023-10-26");
    addOrderToList(&orderList, ord1_node);
    printOrderList(orderList);
    freeOrderList(&orderList);
    */

    printf("\nDemo finished.\n");
    return 0;
}

```

### Makefile

```Makefile
# Makefile

CC = gcc
CFLAGS = -Wall -g # Use c99 for strdup
GSL = gsl

XML_INPUT = entities.xml
GSL_SCRIPT = entity_generator.gsl
MAIN_C = main.c
TARGET = entity_manager

# Infer entity names from the XML to generate list of C and H files
# This is a bit of a hack for Make. A more robust way might be for GSL to output a file list.
# For simplicity, we'll assume entity names don't have spaces or weird chars.
#ENTITIES := $(xmllint --xpath '//entity/@name' $(XML_INPUT) | sed 's| name="\([^"]*\)"|\1|g' | sed -e 'N;s/\n/ /' )
#ENTITIES := Person Product
#ENTITIES := $(shell xmlstarlet sel -t -v '//entity/@name' entities.xml | sed -e 'N;s/\n/ /')
ENTITIES := $(shell xmllint --xpath '//entity/@name' $(XML_INPUT) | sed 's| name="\([^"]*\)"|\1|g' | sed -e 'N;s/\n/ /')

#  | sed 's/name="\([^"]*\)"/\1/g'
GENERATED_H_FILES := $(foreach entity,$(ENTITIES),$(entity).h)
GENERATED_C_FILES := $(foreach entity,$(ENTITIES),$(entity).c)
GENERATED_O_FILES := $(GENERATED_C_FILES:.c=.o)

entities:
	@echo "entities: $(ENTITIES)"

OBJECTS = $(MAIN_C:.c=.o) $(GENERATED_O_FILES)

# Default target
all: $(TARGET)

# Rule to link the executable
$(TARGET): $(OBJECTS)
	$(CC) $(CFLAGS) -o $(TARGET) $(OBJECTS)

# Rule to compile main.c
$(MAIN_C:.c=.o): $(MAIN_C) $(GENERATED_H_FILES)
	$(CC) $(CFLAGS) -c $(MAIN_C) -o $@

# Pattern rule to compile generated .c files
# Each EntityName.o depends on EntityName.c and EntityName.h
%.o: %.c %.h
	$(CC) $(CFLAGS) -c $< -o $@

# Rule to generate all C files from GSL template
# This makes all generated .h and .c files depend on the XML and GSL script
$(GENERATED_H_FILES) $(GENERATED_C_FILES): $(XML_INPUT) $(GSL_SCRIPT)
	@echo "Running GSL to generate C files for entities: $(ENTITIES)..."
	$(GSL) $(XML_INPUT)
	@echo "GSL generation complete."

# Clean rule
clean:
	@echo "Cleaning up..."
	rm -f $(OBJECTS) $(TARGET) $(GENERATED_H_FILES) $(GENERATED_C_FILES)
	@echo "Cleanup complete."

# Phony targets
.PHONY: all clean
```


## Generated artifacts

As this should be a generic entity-generator, this first template generates C-code.
This might not be the cleanest code, however a 'seasoned' C-developer would be able
to provide a working version, which contains best practices for memory-management etc.

This working example could easily be taking by AI or a Human/AI - Centaur to generate
templates for other languages.

So, here come the generated artifiacts.

### Person.h

```c
// Person.h - Generated by GSL for entity Person

#ifndef PERSON_H
#define PERSON_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// --- Definition for Person struct ---
typedef struct Person {
  int id; // Unique identifier for the person;
  char* firstname; // First name of the person;
  char* lastname; // Last name of the person;
  int age; // Age of the person;
} Person;

// --- Definition for PersonNode (Linked List Node) ---
typedef struct PersonNode {
  Person data; // Embeds the actual entity data
  struct PersonNode *next;
} PersonNode;

// --- Function Prototypes for Person Linked List ---
PersonNode* createPersonNode(
  int id,
  const char* firstname,
  const char* lastname,
  int age
);

void addPersonToList(PersonNode** head, PersonNode* newNode);
void printPerson(const Person* entityData);
void printPersonList(const PersonNode* head);
void freePersonList(PersonNode** head);

#endif // PERSON_H

```


### Person.c

```c
// Person.c - Generated by GSL for entity Person

#include "Person.h"
#include <string.h>
// --- Function to create a new PersonNode ---
PersonNode* createPersonNode(
  int id,
  const char* firstname,
  const char* lastname,
  int age
) {
  PersonNode* newNode = (PersonNode*)malloc(sizeof(PersonNode));
  if (newNode == NULL)  goto Person_cleanup;

  // Initialize data fields
  newNode->data.id = id;
  newNode->data.firstname = strdup(firstname);
  if (newNode->data.firstname == NULL && firstname != NULL) goto Person_cleanup;
  newNode->data.lastname = strdup(lastname);
  if (newNode->data.lastname == NULL && lastname != NULL) goto Person_cleanup;
  newNode->data.age = age;

  newNode->next = NULL;
  return newNode;

Person_cleanup:
  // Initialize data fields
  free(newNode->data.firstname);
  free(newNode->data.lastname);
  free(newNode);
  return NULL;
}

// --- Function to add a PersonNode to the end of the list ---
void addPersonToList(PersonNode** head, PersonNode* newNode) {
  if (newNode == NULL) return;
  if (*head == NULL) {
    *head = newNode;
  } else {
    PersonNode* current = *head;
    while (current->next != NULL) {
      current = current->next;
    }
    current->next = newNode;
  }
}

// --- Function to print details of a single Person ---
void printPerson(const Person* entityData) {
    if (entityData == NULL) {
      printf("  (null Person data)\n");
      return;
    }
    printf("  Person Details:\n");
    printf("    id: %d\n", entityData->id);
    printf("    firstname: %s\n", entityData->firstname ? entityData->firstname : "(null)");
    printf("    lastname: %s\n", entityData->lastname ? entityData->lastname : "(null)");
    printf("    age: %d\n", entityData->age);
}

// --- Function to print all Persons in the list ---
void printPersonList(const PersonNode* head) {
  const PersonNode* current = head;
  if (current == NULL) {
    printf("Person list is empty.\n");
    return;
  }
  printf("\n--- Person List ---\n");
  int count = 1;
  while (current != NULL) {
    printf("Node %d:\n", count++);
    printPerson(&(current->data));
    current = current->next;
  }
  printf("----------------------\n");
}

// --- Function to free the entire Person linked list ---
void freePersonList(PersonNode** head) {
  PersonNode* current = *head;
  PersonNode* nextNode;
  while (current != NULL) {
    nextNode = current->next;
    // Free dynamically allocated strings within the data struct
    free(current->data.firstname);
    free(current->data.lastname);
    free(current); // Free the node itself
    current = nextNode;
  }
  *head = NULL;
}

```
