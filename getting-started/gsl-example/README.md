

---
description: GSL Templating using Gemini 2.5 Pro
---

# Generator Scripting Language - teaching Gemini

During a recent course AI was explained and someone mentioned that
Gemini performs better then DeepSeek and ChatGPT in coding tasks.

So I took that opertunity to:

1. Teach Gemini about GSL ( www.github.com/zeromq/gsl)
2. Provide the README.txt file as context
3. Explain what I wanted.

## The assignment

I want to teach you about GSL, more context is provided here: [README.txt](https://github.com/zeromq/gsl/blob/master/README.txt).

Ask: Write an entities.xml file which contains some entities with typical fields such as name,age etc.

Gemini produced: 

### entities.xml

```xml
{% include "entities.xml" %}
```

After this I requested it to write the gsl-template to generate, on the basis of the entity-format C-structs.

### entity_generator.gsl
The resulting template after some back and forth looks like this:

{% include "entity_generator.gsl" language="c" %}

I then asked it to generate a main.c file and a Makefile in order to compile the entire example:

### main.c

```c
{% include "main.c" %}
```

### Makefile

```Makefile
{% include "Makefile" %}
```


## Generated artifacts

As this should be a generic entity-generator, this first template generates C-code.
This might not be the cleanest code, however a 'seasoned' C-developer would be able
to provide a working version, which contains best practices for memory-management etc.

This working example could easily be taking by AI or a Human/AI - Centaur to generate
templates for other languages.

So, here come the generated artifiacts.

### Person.h

{% code title="Person.h" overflow="wrap" lineNumbers="true" lanaguage="c" %}
// Person.h - Generated by GSL for entity Person

#ifndef PERSON_H
#define PERSON_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// --- Definition for Person struct ---
typedef struct Person {
  int id; // Unique identifier for the person;
  char* firstname; // First name of the person;
  char* lastname; // Last name of the person;
  int age; // Age of the person;
} Person;

// --- Definition for PersonNode (Linked List Node) ---
typedef struct PersonNode {
  Person data; // Embeds the actual entity data
  struct PersonNode *next;
} PersonNode;

// --- Function Prototypes for Person Linked List ---
PersonNode* createPersonNode(
  int id,
  const char* firstname,
  const char* lastname,
  int age
);

void addPersonToList(PersonNode** head, PersonNode* newNode);
void printPerson(const Person* entityData);
void printPersonList(const PersonNode* head);
void freePersonList(PersonNode** head);

#endif // PERSON_H

{% endcode %}


### Person.c

{% code title="Person.c" overflow="wrap" lineNumbers="true" lanaguage="c" %}
// Person.c - Generated by GSL for entity Person

#include "Person.h"
#include <string.h>
// --- Function to create a new PersonNode ---
PersonNode* createPersonNode(
  int id,
  const char* firstname,
  const char* lastname,
  int age
) {
  PersonNode* newNode = (PersonNode*)malloc(sizeof(PersonNode));
  if (newNode == NULL)  goto Person_cleanup;

  // Initialize data fields
  newNode->data.id = id;
  newNode->data.firstname = strdup(firstname);
  if (newNode->data.firstname == NULL && firstname != NULL) goto Person_cleanup;
  newNode->data.lastname = strdup(lastname);
  if (newNode->data.lastname == NULL && lastname != NULL) goto Person_cleanup;
  newNode->data.age = age;

  newNode->next = NULL;
  return newNode;

Person_cleanup:
  // Initialize data fields
  free(newNode->data.firstname);
  free(newNode->data.lastname);
  free(newNode);
  return NULL;
}

// --- Function to add a PersonNode to the end of the list ---
void addPersonToList(PersonNode** head, PersonNode* newNode) {
  if (newNode == NULL) return;
  if (*head == NULL) {
    *head = newNode;
  } else {
    PersonNode* current = *head;
    while (current->next != NULL) {
      current = current->next;
    }
    current->next = newNode;
  }
}

// --- Function to print details of a single Person ---
void printPerson(const Person* entityData) {
    if (entityData == NULL) {
      printf("  (null Person data)\n");
      return;
    }
    printf("  Person Details:\n");
    printf("    id: %d\n", entityData->id);
    printf("    firstname: %s\n", entityData->firstname ? entityData->firstname : "(null)");
    printf("    lastname: %s\n", entityData->lastname ? entityData->lastname : "(null)");
    printf("    age: %d\n", entityData->age);
}

// --- Function to print all Persons in the list ---
void printPersonList(const PersonNode* head) {
  const PersonNode* current = head;
  if (current == NULL) {
    printf("Person list is empty.\n");
    return;
  }
  printf("\n--- Person List ---\n");
  int count = 1;
  while (current != NULL) {
    printf("Node %d:\n", count++);
    printPerson(&(current->data));
    current = current->next;
  }
  printf("----------------------\n");
}

// --- Function to free the entire Person linked list ---
void freePersonList(PersonNode** head) {
  PersonNode* current = *head;
  PersonNode* nextNode;
  while (current != NULL) {
    nextNode = current->next;
    // Free dynamically allocated strings within the data struct
    free(current->data.firstname);
    free(current->data.lastname);
    free(current); // Free the node itself
    current = nextNode;
  }
  *head = NULL;
}

{% endcode %}

